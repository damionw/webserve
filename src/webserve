#!/usr/bin/env bash

#===================================================================================
#                                  Constants
#===================================================================================
VERSION=0.09

#===================================================================================
#                              Response Functions
#===================================================================================
response::set_status() {
    local _code="${1}"
    local _version="${2}"

    local HTTP_CODE=(
        [200]="OK"
        [400]="Bad Request"
        [403]="Forbidden"
        [404]="Not Found"
        [405]="Method Not Allowed"
        [500]="Internal Server Error"
    )

    headers[0]="${_version} ${_code} ${HTTP_CODE[${_code}]}"
}

response::send() {
    # Response content comes in via stdin
    (response::get_headers; echo) | sed -e 's/$/\r/'
    cat
}

response::add_header() {
    headers[${#headers[@]}]="$*"
}

response::get_headers() {
    local _index

    for ((_index=0; _index < ${#headers[@]}; ++_index)) {
        echo "${headers[${_index}]}"
    }
}

#===================================================================================
#                                Headers
#===================================================================================
header::server_type() {
    response::add_header "Server: ${HTTP_SCRIPT}"
}

header::text_html() {
    header::content_type text/html
}

header::text_plain() {
    header::content_type "text/plain; charset=utf-8"
}

header::application_octet_stream() {
    header::content_type application/octet-stream
}

header::application_json() {
    header::content_type application/json
}

header::application_javascript() {
    header::content_type application/javascript
}

header::text_css() {
    header::content_type text/css
}

header::content_type() {
    response::add_header "Content-Type: ${1}"
}

header::content_length() {
    test "${1:-0}" -gt 0 && response::add_header "Content-Length: ${1}"
}

header::access_control() {
    response::add_header "Access-Control-Allow-Headers: ${1}"
    response::add_header "Access-Control-Allow-Origin: ${1}"
}

#===================================================================================
#                                TCP/IP
#===================================================================================
tcp::available_ports() {
    start_port=${1:-10000}
    protocol=${2:-tcp}

    address_family=$(echo ${protocol}4 | sed -e 's/^[^0-9]*//g' | dd bs=1 count=1 2>/dev/null)
    protocol=$(echo ${protocol} | sed -e 's/[0-9].*$//g')

    netstat -ln --${protocol} -${address_family} |
    awk '{print $4;}' |
    awk -F: '{print $2;}' |
    sed -e '/^[ ]*$/d' |
    sort -n |
    awk '{
        for (; i < $1; ++i)
        {
            print i;
        }

        if (i == $1)
        {
            ++i;
        }
    }' i=${start_port}
}

tcp::get_unused_port() {
    tcp::available_ports $* | (read row && echo $row)
}

#===================================================================================
#                                URL Matching
#===================================================================================
url::add_handler() {
    local _regex="${1}"
    local _methods="${2}" # GET,POST
    local _handler="${3}" # http::handler...

    URL_REGEXES["${#URL_REGEXES[@]}"]="_regex='${_regex}'; _methods='${_methods}'; _handler='${_handler}'"
}

url::match_handler() {
    local _method="${1}"
    local _request="${2}"

    local _regex
    local _methods
    local _handler
    local _index

    for ((_index=0; _index < ${#URL_REGEXES[@]}; ++_index)) {
        eval "${URL_REGEXES[${_index}]}"

        if [ -z "$(echo "${_request}" | awk "/${_regex}/"'{print $1;}')" ]
        then
            :
        elif ! (echo "${_methods}" | awk -F, '{for (i=1; i <= NF; ++i) {print $i;}}' | grep -q '^'"${_method}"'$')
        then
            :
        else
            echo "${_handler}"
            return 0
        fi
    }

    return 255
}

#===================================================================================
#                                HTTP Handlers
#===================================================================================
logging::info() {
    local _retval=$?
    echo -e "$(date '+%Y-%m-%d %H:%M:%S'): $*" >&2
    return $_retval
}

logging::fatal() {
    local _retval=$?
    echo -e "$(date '+%Y-%m-%d %H:%M:%S'): $*" >&2
    exit $_retval
}

http::400_error() {
    response::set_status 400 "HTTP/1.1"
    header::server_type
    echo "ERROR" | response::send
}

http::404_error() {
    response::set_status 404 "HTTP/1.1"
    header::server_type
    echo "ERROR" | response::send
}

http::response_html() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::text_html
    response::send
}

http::response_json() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::application_json
    response::send
}

http::response_css() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::text_css
    response::send
}

http::response_octet_stream() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::application_octet_stream
    header::access_control '*'
    response::send
}

http::response_javascript() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::application_javascript
    header::access_control '*'
    response::send
}

http::response_plain() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::text_plain
    response::send
}

http::response_file() {
    local _method="${1}"
    local _request="${2}"
    local _headers="${3}"
    local _content="${4}"
    local _filename="${5:-_SERVER_STATIC}/$(basename "${_request}")"
    local _extension="$(echo "${_filename}" | awk -F. '{print $NF;}' | tr '[A-Z]' '[a-z]')"

    if [ ! -f "${_filename}" ]
    then
        http::404_error
        return 255
    fi

    case "${_extension}" in
        html)
            http::response_html
            ;;

        js)
            http::response_javascript
            ;;

        json)
            http::response_json
            ;;

        css)
            http::response_css
            ;;

        *)
            response::set_status 200 "HTTP/1.1"
            header::server_type
            header::content_type "$(file -b --mime-type "${_filename}")"
            # header::content_length "$(wc -c < "${_filename}")"
            header::access_control '*'
            response::send
            ;;
    esac < "${_filename}"
}

http::response_directory_listing() {
    local _folder="${1}"
    local _urlpath="${2:-/}"
    local _iconurl="${_urlpath}/icons"

    if [ ! -d "${_folder}" ]
    then
        http::404_error
        return 255
    fi

    HTML_TEMPLATE='
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
        <html>
        <head>
        <title>Index of __PATH_URL__</title>
        </head>
        <body>
        <h1>Index of __PATH_URL__</h1>
        <table>
        __HEADER__
        __PARENT__
        __ENTRIES__
        </table>
        </body></html>
    '

    HEADER_TEMPLATE='
        <tr>
            <th valign="top"></th>
            <th>Name</th>
            <th>Last modified</th>
            <th>Size</th>
            <th>Description</th>
        </tr>
        <tr>
            <th colspan="5"><hr></th>
        </tr>
    '

    PARENT_TEMPLATE='
        <tr>
            <td valign="top"><img src="__ICON_URL__" alt="[PARENTDIR]"></td>
            <td><a href="__PARENT_URL__">Parent Directory</a></td>
            <td>&nbsp;</td>
            <td align="right">  - </td>
            <td>&nbsp;</td>
        </tr>
    '

    ENTRY_TEMPLATE='
        <tr>
            <td valign="top"><img src="__ICON_URL__" alt="[DIR]"></td>
            <td><a href="__PATH_URL__/__NAME__">__NAME__</a></td>
            <td align="right">__DATE__</td>
            <td align="right">__SIZE__</td>
            <td>&nbsp;</td>
        </tr>
    '

    {
        sed -e 's/^        //g' <<< "${HTML_TEMPLATE}" | m4 --prefix-builtins \
            -D__PATH_URL__="${_urlpath}" \
            -D__HEADER__="$(
                echo "${HEADER_TEMPLATE}" | m4 --prefix-builtins
            )" \
            -D__PARENT__="$(
                echo "${PARENT_TEMPLATE}" | m4 --prefix-builtins \
                    -D__PARENT_URL__="$(dirname "${_urlpath}")" \
                    -D__ICON_URL__="${_iconurl}/back.png"
            )" \
            -D__ENTRIES__="$(
                find "${_folder}" -maxdepth 1 -mindepth 1 -printf "%Y %s %TY-%Tm-%Td %TH:%TM %f\n" | while read _type _size _date _time _name
                do
                    local mime="$(
                        case "${_type}" in
                            d)
                                echo "folder"
                                ;;
                            f)
                                echo "document"
                                ;;
                            *)
                                echo "document"
                                ;;
                        esac
                    )"

                    echo "${ENTRY_TEMPLATE}" | m4 --prefix-builtins \
                        -D__PATH_URL__="${_urlpath}" \
                        -D__DATE__="${_date} ${_time}" \
                        -D__SIZE__="${_size}" \
                        -D__NAME__="${_name}" \
                        -D__ICON_URL__="${_iconurl}/${mime}.png"
                done
            )"
    } | http::response_html 
}

http::response_api_catalog() {
    listify() {
        sort -n |
        awk 'BEGIN {print "[";} {printf("%s%s", sep, $0); sep=",";} END {print "]";}'
    }

    local _api_folder="${_SERVER_API}"

    if ! [ -n "${_api_folder}" -a -d "${_api_folder}" ]
    then
        http::404_error
        return
    fi

    find "${_api_folder}" -mindepth 1 -maxdepth 1 -type f -printf '"%f"\n' |
    listify |
    http::response_json
}

http::response_script() {
    local _method="${1}"
    local _request="${2}"
    local _headers="${3}"
    local _content="${4}"
    local _action="$(basename "${_request}")"
    local _filename="${_SERVER_API}/${_action}"

    if result="$("${_filename}")" # Result must be valid JSON object
    then
        echo "{\"action\": \"${_action}\", \"result\": ${result}}" | http::response_json
    else
        http::400_error
    fi
}

http::handle_request() {
    # Initialize the reply headers collection
    headers=(
        "HTTP/1.1 200 OK"
    )

    URL_REGEXES=()

    local _method
    local _request
    local _version
    local _handler

    local _store _block

    while true
    do
        # WARNING: We hold the contents as base64 because bash variables (C strings) cannot hold null bytes
        _block="$(timeout 0.5s dd bs=1024 count=1 2>/dev/null | base64)"
        test -z "${_block}" && break
        _store="${_store}${_block}"
    done

    # Find edge between headers and content by parsing characters in hex notation
    local _offset="$(
        echo -ne "${_store}" |
        base64 --decode |
        hexdump -v -e '/1 "%02X "' |
        sed -e 's/\(0D 0A 0D 0A \).*$/\1/g' |
        sed -e 's/ /\n/g' |
        wc -l
    )"

    # Grab the headers, removing CR characters
    local _preamble="$(
        echo -n "${_store}" |
        base64 --decode |
        dd bs=1 count=${_offset} 2>/dev/null |
        sed -e 's/\r//g'
    )"

    if ! read _method _request _version <<< "${_preamble}"
    then
        http::400_error
        return 255
    fi

    logging::info "[${_method}] [${_request}] [${_version}]"

    # Register the regexes and callbacks
    http::url_mappings

    # Find the appropriate handler
    if ! _handler="$(url::match_handler "${_method}" "${_request}")"
    then
        http::404_error
        return 255
    fi

    # Grab the content in base64 format
    local _b64_content="$(
        echo -n "${_store}" |
        base64 --decode |
        dd bs=1 skip=${_offset} 2>/dev/null |
        base64
    )"

    # Convert content to plain form.
    # WARNING: bash variables elide null bytes
    local _content="$(
        echo -n "${_b64_content}" |
        base64 --decode
    )"

    local _headers="$(
        echo "${_preamble}" |
        tail --lines=+2
    )"

    # Call the handler with <method> <request> <headers> <content> <base64 content>
    "${_handler:-"http::404_error"}" "${_method}" "${_request}" "${_headers}" "${_content}" "${_b64_content}" | stdbuf --output=0 cat &&sleep 1
}

http::run_server() {
    local _shell="$(which bash)"
    local _port="${1}"
    shift

    local address_spec=$(
        echo $* |
        sed -e 's/[ ]/\n/g' |
        sort -u |
        awk '{printf("%s--allow %s", sep, $1); sep=" ";}'
    )

    if [ -z "${_port}" ]
    then
        logging::fatal "Need to supply a server port"
    fi

    logging::info "Starting webserver on port ${_port} with static folder '${_SERVER_STATIC}'"

    NCAT_LOCAL_ADDR="$(hostname)" NCAT_LOCAL_PORT=${_port} exec ncat \
        -l ${_port} \
        --max-conns 12 \
        --keep-open \
        ${address_spec} \
        --sh-exec "'${_shell}' -c '. \"${_SERVER_SCRIPT}\" </dev/null >/dev/null 2>&1; http::handle_request'"
}

http::url_mappings() {
    # Import external module url mappings
    for name in $(declare -F | awk '{print $NF;}' | grep '^http::[0-9a-zA-Z_][0-9a-zA-Z_]*::url_mappings')
    do
        logging::info "Import url mappings from ${name}"
        "${name}"
    done

    url::add_handler '^\/static\/.*$' GET http::response_file

    if [ -n "${_SERVER_API}" -a -d "${_SERVER_API}" ]
    then
        url::add_handler '^\/api\/*$'  GET http::response_api_catalog
        url::add_handler '^\/api\/.*$' GET http::response_script
    fi
}

#===================================================================================
#               Break out here if running in the request handling context
#===================================================================================
if ${_IN_SERVER_REQUEST_HANDLER:=false}
then
    _modules="$(echo "${_SERVER_MODULES}" | sed -e '/^[ ]*$/d' | sort -u)"
    _index=0

    while [ -n "${_modules}" ]
    do
        ((++_index))

        _module="$(readlink -f "$(echo "${_modules}" | head -1)")"
        _modules="$(echo "${_modules}" | tail --lines=+2)"
        logging::info "Loading ${_module}"

        # Extract http::<name> function definitions and transform only the declaration names to http::<index>::<name>
        _definitions="$(
            bash -c ". '${_module}'"'; for name in $(declare -F | awk '"'"'{print $NF;}'"'"' | grep "^http::"); do declare -f "${name}"; done' |
            sed -e 's/^http::\([0-9a-zA-Z_][0-9a-zA-Z_]*\)[ ]/http::'"${_index}"'::\1 /g'
        )"

        # Import modified functions into local namespace
        eval "${_definitions}"
    done

    return
fi

#===================================================================================
#                              Help Message
#===================================================================================
showhelp()
{
    contents=$(
        echo "${*}" |
        awk -F, '{for (i=1; i <= NF; ++i) {print $i;}}' |
        awk -F: '{printf("%s[--%s%s]", sep, $1, (NF == 2 ? sprintf("=<%s>", $1) : "")); sep=" "}'
    )

    echo "Usage: $0 ${contents}" >&2
}

#===================================================================================
# NOTE: There is a bug in getopts where not specifying at least one short option
#       will cause the first non option parameter to be discarded. Here, we just
#       use -h (help)
#===================================================================================
long_options="api:,static:,help,port:,address:,allow:,module:,version"

OPTION_TEMP=$(getopt -a -o hva:s:p:m: --long ${long_options} -- "$@")

if [ $? != 0 ]
then
    echo "Invalid command line options ${OPTION_TEMP}" >&2
    exit 15
fi

eval set -- "$OPTION_TEMP"

#===================================================================================
#                       Process command line parameters
#
# NOTE: The command line parameters are available for scripts which
#       source this file.
#===================================================================================
export _SERVER_SCRIPT="${BASH_SOURCE[0]}"
export _SERVER_STATIC="$(dirname "${SERVER_SCRIPT}")"
export _SERVER_API=
export _SERVER_MODULES=

listener_port=$(tcp::get_unused_port)
listener_addresses=("127.0.0.1")

while true
do
    case "$1" in
        --version|-v)
            echo "${VERSION}"
            exit 0
            ;;

        --address|--allow)
            listener_addresses[${#listener_addresses[*]}]="$2"
            shift 2
            ;;

        --port|-p)
            listener_port=$2
            shift 2
            ;;

        --module|-m)
            _SERVER_MODULES="$(echo "${_SERVER_MODULES}"; echo "${2}")"
            shift 2
            ;;

        --static|-s)
            export _SERVER_STATIC="$(readlink -f "${2}")"
            shift 2
            ;;

        --api)
            export _SERVER_API="$(readlink -f "${2}")"
            shift 2
            ;;

        --)
            shift
            break
            ;;

        *)
            showhelp "${long_options}" >&2
            exit 0
            ;;
    esac
done

#===================================================================================
#                 Run server with options and setting context
#===================================================================================
_IN_SERVER_REQUEST_HANDLER=true http::run_server "${listener_port}" ${listener_addresses[*]}
